{"ast":null,"code":"import { node, linkedList, serialize } from './linkedList';\n\nconst processCode = () => {\n  let linkedlist = new linkedList();\n  let head = linkedlist[0];\n  let states = []; // Paste the routine here\n\n  let node1 = new node('null');\n  states.push(serialize(linkedlist));\n  let node2 = head;\n  states.push(serialize(linkedlist));\n  let node3 = node2.next;\n  states.push(serialize(linkedlist));\n\n  while (node3.val !== 'null') {\n    states.push(serialize(linkedlist));\n    node2.next = node1;\n    states.push(serialize(linkedlist));\n    node1 = node2;\n    states.push(serialize(linkedlist));\n    node2 = node3;\n    states.push(serialize(linkedlist));\n    node3 = node3.next;\n    states.push(serialize(linkedlist));\n  }\n\n  node2.next = node1;\n  states.push(serialize(linkedlist));\n  node1 = node2;\n  states.push(serialize(linkedlist));\n  head = node1;\n  states.push(serialize(linkedlist)); // routine ends here\n\n  return states;\n};\n/*\nCore algorithm:\n  1. Watch for new nodes and communicate it to the frontend\n  2. Watch for copy of any of the nodes and replace the copy in the list\n*/\n\n/*\nfunction reverse(head) {\n  let node1 = new node('null');\n  let node2 = head;\n  let node3 = node2.next;\n  while (node3.val !== 'null') {\n    node2.next = node1;\n    node1 = node2;\n    node2 = node3;\n    node3 = node3.next;\n  }\n  node2.next = node1;\n  node1 = node2;\n  head = node1;\n  return head;\n}*/\n\n\nexport { processCode };","map":{"version":3,"sources":["/Users/karthikkalyanaraman/reactive-algorithms/src/backend.js"],"names":["node","linkedList","serialize","processCode","linkedlist","head","states","node1","push","node2","node3","next","val"],"mappings":"AAAA,SAASA,IAAT,EAAeC,UAAf,EAA2BC,SAA3B,QAA4C,cAA5C;;AAEA,MAAMC,WAAW,GAAG,MAAM;AACxB,MAAIC,UAAU,GAAG,IAAIH,UAAJ,EAAjB;AACA,MAAII,IAAI,GAAGD,UAAU,CAAC,CAAD,CAArB;AACA,MAAIE,MAAM,GAAG,EAAb,CAHwB,CAKxB;;AACA,MAAIC,KAAK,GAAG,IAAIP,IAAJ,CAAS,MAAT,CAAZ;AACAM,EAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;AACA,MAAIK,KAAK,GAAGJ,IAAZ;AACAC,EAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;AACA,MAAIM,KAAK,GAAGD,KAAK,CAACE,IAAlB;AACAL,EAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;;AACA,SAAOM,KAAK,CAACE,GAAN,KAAc,MAArB,EAA6B;AAC3BN,IAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;AACAK,IAAAA,KAAK,CAACE,IAAN,GAAaJ,KAAb;AACAD,IAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;AACAG,IAAAA,KAAK,GAAGE,KAAR;AACAH,IAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;AACAK,IAAAA,KAAK,GAAGC,KAAR;AACAJ,IAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;AACAM,IAAAA,KAAK,GAAGA,KAAK,CAACC,IAAd;AACAL,IAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;AACD;;AACDK,EAAAA,KAAK,CAACE,IAAN,GAAaJ,KAAb;AACAD,EAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;AACAG,EAAAA,KAAK,GAAGE,KAAR;AACAH,EAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB;AACAC,EAAAA,IAAI,GAAGE,KAAP;AACAD,EAAAA,MAAM,CAACE,IAAP,CAAYN,SAAS,CAACE,UAAD,CAArB,EA5BwB,CA6BxB;;AACA,SAAOE,MAAP;AACD,CA/BD;AAiCA;;;;;;AAMA;;;;;;;;;;;;;;;;;;AAkBA,SAASH,WAAT","sourcesContent":["import { node, linkedList, serialize } from './linkedList'\n\nconst processCode = () => {\n  let linkedlist = new linkedList();\n  let head = linkedlist[0];\n  let states = []\n\n  // Paste the routine here\n  let node1 = new node('null');\n  states.push(serialize(linkedlist));\n  let node2 = head;\n  states.push(serialize(linkedlist));\n  let node3 = node2.next;\n  states.push(serialize(linkedlist));\n  while (node3.val !== 'null') {\n    states.push(serialize(linkedlist));\n    node2.next = node1;\n    states.push(serialize(linkedlist));\n    node1 = node2;\n    states.push(serialize(linkedlist));\n    node2 = node3;\n    states.push(serialize(linkedlist));\n    node3 = node3.next;\n    states.push(serialize(linkedlist));\n  }\n  node2.next = node1;\n  states.push(serialize(linkedlist));\n  node1 = node2;\n  states.push(serialize(linkedlist));\n  head = node1;\n  states.push(serialize(linkedlist));\n  // routine ends here\n  return states;\n}\n\n/*\nCore algorithm:\n  1. Watch for new nodes and communicate it to the frontend\n  2. Watch for copy of any of the nodes and replace the copy in the list\n*/\n\n/*\nfunction reverse(head) {\n  let node1 = new node('null');\n  let node2 = head;\n  let node3 = node2.next;\n  while (node3.val !== 'null') {\n    node2.next = node1;\n    node1 = node2;\n    node2 = node3;\n    node3 = node3.next;\n  }\n  node2.next = node1;\n  node1 = node2;\n  head = node1;\n  return head;\n}*/\n\n\nexport { processCode }\n"]},"metadata":{},"sourceType":"module"}